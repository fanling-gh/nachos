# 3.2 Lab 2: Threads and Synchronization 

In this assignment, you will complete the Nachos thread system by adding support for locks (mutexes), condition variables, and build some synchronized data structures for use in the later labs. There is an extra-credit part to this lab, which has you modify the default **nachos** scheduling behavior to implement a non-preemptive priority-based scheduler. 

As with Lab 1, this lab also requires you to introduce one or more files of your own. As before, you will need to add these files to proper macro definitions in the `makefile`, and update the `makefile` dependencies. Note that the latter half of this assignment requires you to use the synchronization facilities you will be implementing in the first part. So, please try and make sure that your implementation of locks and condition variables is thoroughly debugged before you move on to the rest of the assignment. 

Your new classes will be based on header files provided in the course directory (subdirectory aux) and/or on the course web site. These header files contain initial definitions of the classes, with the signatures of some methods. You should copy these header files into your source pool and extend them. Feel free to add your own methods, definitions, and classes as needed. However, do not modify the interfaces, which are already defined. 

### 3.2.1 Implementing Mutexes and Condition Variables (60 points) 

The public interface to mutexes and condition variables is defined in `synch.h` , which includes important comments on the semantics of the primitives. The condition variable interface is clunky in some respects, but please just accept it as defined by `synch.h` . Your first mission is to define private data for these classes in `synch.h` and implement the interfaces in `synch.cc` . Look at `SynchList` to see how the synchronization primitives for mutexes and condition variables are used. You are to write two different implementations of these synchronization primitives in two different versions of the `synch.h` and `synch.cc` files. You should be able to switch from one version to the other by (at worst) moving these files around and recompiling Nachos. Each implementation is worth 30 points in this lab. 

Here are the specific steps and requirements in more detail: 

1. Implement your locks and condition variables using the sleep/wakeup primitives (the `Thread::Sleep` and `Scheduler::ReadyToRun` primitives). **It will be necessary to disable interrupts temporarily at strategic points**, to eliminate the possibility of an ill-timed interrupt or involuntary context switch. In particular, `Thread::Sleep` **requires you to disable interrupts before you call it.** However, you may lose points for holding interrupts disabled when it is not necessary to do so. Disabling interrupts is a blunt instrument and should be avoided unless necessary. 

2. Implement your locks and condition variables using semaphores as the only synchronization primitive. **This time it is not necessary (or permitted) to disable interrupts in your code**: the semaphore primitives disable interrupts as necessary to implement the semaphore abstraction, which you now have at your disposal as a sufficient "toehold" for synchronization. **Warning** : this part of the assignment seems easy but it is actually the most subtle and difficult. In particular, your solution for condition variables should guarantee that a `Signal` cannot affect a subsequent `Wait`. 

3. Modify your `DLList` class from Lab 1 so that it uses synchronization primitives to ensure that the list is being updated consistently despite its use by multiple threads. You may want to take a look at the `SynchList` class (in `threads/synchlist.h` and `threads/synchlist.cc` ) to see how you might do this. To demonstrate that your code works, as in Lab 1, create a driver file analogous to the file `threadtest.cc` that makes calls on the synchronized version of the `DLList` class. Make the changes to `threads/main.cc` so that an execution of the nachos command causes the function in the new driver file to be executed instead of the function `ThreadTest` in the file `threadtest.cc` . Use the synchronized version of `DLList` to test both versions of your locks and condition variables.

### 3.2.2 Implementing a Multithreaded Table (20 points) 

   Implement a thread-safe `Table` class, which stores a collection of untyped object pointers indexed by integers in the range `[0..size-1]`. You may use Table in later labs to implement internal operating system tables of processes, threads, memory page frames, open files, etc. Table has the following methods, defined in the header file `Table.h`, which is provided in the course directory (subdirectory `aux`): 

`Table(int size)` *-- Create a table to hold at most size entries.* 

`int Alloc (void* object)` *-- Allocate a table slot for object, returning index of the allocated entry. Return an error (-1) if no free table slots are available.*

`void* Get (int index)` *-- Retrieve the object from table slot at index, or NULL if not allocated.* 

`void Release (int index)` *-- Free the table slot at index.* 

### 3.2.3 Implementing a Bounded Buffer (20 points) 

This is a classical synchronization problem called bounded producer/consumer. Implement a thread-safe `BoundedBuffer` class, based on the definitions in `*/aux/BoundedBuffer.h` . 

`BoundedBuffer(int maxsize)` *-- Create a bounded buffer to hold at most `maxsize` bytes.* 

`void Read (void* data, int size)` -- *Read size bytes from the buffer, blocking until enough bytes are available to completely satisfy the request. Copy the bytes into memory starting at address data* 

`void Write (void* data, int size)` *-- Write size bytes into the buffer, blocking until enough space is available to completely satisfy the request. Copy the bytes from memory starting at address data .* 

`BoundedBuffer` will be used in Lab 5 to implement pipes, an inter-process communication (IPC) mechanism fundamental to Unix systems. The basic idea is that the pipe or `BoundedBuffer` passes data from a producer thread (which calls `Write` ) to a consumer thread (which calls `Read`). The consumer receives the bytes placed in the buffer with `Write` , in the same order as those bytes were written by the producer. If the producer generates data too fast (i.e. the buffer overflows with more than `maxsize` bytes) then `Write` puts the producer to sleep until the consumer can catch up and read some data from the buffer, freeing up space. If the consumer reads data too fast (i.e., the buffer empties), then `Read` puts the consumer to sleep until the producer can catch up and generate some more bytes. 

Note that there is no restriction on which threads call `Read` and which call `Write` . Your implementation should not assume that only only two threads use it, or that the calling threads play fixed roles as producer and consumer. If a given `BoundedBuffer` is used by multiple threads, then you should take care to preserve the atomicity of `Read` and `Write` requests. That is, data written by a given `Write` should never be delivered to a reader interleaved with data from other `Write` operations. This invariant should hold even if writers and/or readers are forced to block because the buffer fills up or drains. 

### 3.2.4 (EXTRA CREDIT) Implementing a Priority Scheduler (20 points) 

Trace through the code in `threads/thread.cc`, `threads/scheduler.h` and `threads/scheduler.cc` to understand how the default nachos scheduler chooses the next thread to run (either when a thread explicitly yields the CPU, or when a timeslice completes). To implement a non-preemptive priority-based scheduler, modify the thread scheduler to always return the highest priority thread. You might want to copy `scheduler.h` and `scheduler.cc` into files that have different names and modify these copies instead of the original ones. You will also need to create a new constructor for Thread to take another parameter – the priority level of the thread. Please leave the old constructor as is, since you will need it for backward compatibility. You may assume that there are a small, fixed number of priority levels – for this assignment you will only need two. 

Test your scheduler implementation by using it to run your bounded buffer implementation. Can changing the relative priorities of the producer and consumer threads have any effect on the output? For instance, what happens with two producers and one consumer, when one of the producers is higher priority than the other? What if the two producers are at the same priority, but the consumer is at high priority? To get the desired behaviors, make sure that you have calls to `Thread::Yield` in your producer and consumer code (just for this part of the lab). 

### 3.2.5 Some Notes for Lab 2 

Your implementations of locks and condition variables should use `ASSERT` checks as described in Section 2.2 (See Tracing and Debugging Nachos Programs) to enforce any usage constraints necessary for correct behavior. For example, every call to `Signal` and `Wait` passes an associated mutex; what could go wrong if a given condition variable is used with more than one mutex? What will happen if a lock holder attempts to acquire a held lock a second time? What if a thread tries to release a lock that it does not hold? These `ASSERT` checks are worth points on this assignment, and they will save you headaches in later assignments. 

You will also need to consider other usage issues. For example, what should your implementation do if the caller tries to delete a mutex or condition variable object while there are threads blocked on it? 

You should be able to explain why your implementation is correct (e.g., what will happen if we put a yield between lines X and Y), and to comment on its behavior (fairness, starvation, etc.) under various usage scenarios. 

**Warning**: The Nachos condition variable interface is ugly in that it passes the associated mutex on every call to `Wait` or `Signal`, rather than just binding the mutex once in the condition variable constructor. This means you must add code to remember the mutex on the first call to `Wait` or `Signal` , so that you can verify correct usage in subsequent calls. But make no mistake: each condition variable is used with exactly one mutex, as stated in `synch.h` . Be sure you understand why this is so important. 

**Warning**: The definition of semaphores does not guarantee that a thread awakened in **V** will get a chance to run before another thread calls **P** . In particular, the Nachos implementation of semaphores does not guarantee this behavior. That is, **V** increments the count and wakes up a blocked thread if the count transitioned from zero to one, but it is the responsibility of the awakened thread to decrement the count again after it wakes up in **P** . If another thread calls **P** first, then it may consume the count that was "meant for" the awakened thread, which will cause the awakened thread to go back to sleep and wait for another **V** . 

**Note**: for debugging, you may use the **-s** debug flag. However, there are no current **DEBUG** statements with the **s** debug flag, so you will need to add some to your code. See Section 2.2 (See Tracing and Debugging Nachos Programs). 